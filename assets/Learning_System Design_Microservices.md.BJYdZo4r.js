import{_ as e,c as s,o as a,a4 as n}from"./chunks/framework.B7YSrJ1r.js";const v=JSON.parse('{"title":"How Microservices Talk to Each Other?","description":"","frontmatter":{},"headers":[],"relativePath":"Learning/System Design/Microservices.md","filePath":"Learning/System Design/Microservices.md","lastUpdated":1725889675000}'),o={name:"Learning/System Design/Microservices.md"},t=n(`<h1 id="how-microservices-talk-to-each-other" tabindex="-1">How Microservices Talk to Each Other? <a class="header-anchor" href="#how-microservices-talk-to-each-other" aria-label="Permalink to &quot;How Microservices Talk to Each Other?&quot;">​</a></h1><p>Microservices can communicate using synchronous (REST, gRPC) or asynchronous (message queues, event-driven) approaches.</p><h2 id="synchronous-communication-request-response-model" tabindex="-1">Synchronous Communication (Request-Response Model) <a class="header-anchor" href="#synchronous-communication-request-response-model" aria-label="Permalink to &quot;Synchronous Communication (Request-Response Model)&quot;">​</a></h2><p>In synchronous communication, one microservice sends a request to another and waits for a response. The client must wait for the response to proceed. This is most commonly done using HTTP/HTTPS or gRPC.</p><h3 id="rest-representational-state-transfer" tabindex="-1">REST (Representational State Transfer): <a class="header-anchor" href="#rest-representational-state-transfer" aria-label="Permalink to &quot;REST (Representational State Transfer):&quot;">​</a></h3><p>Microservices communicate over HTTP using standard protocols like GET, POST, PUT, DELETE, etc. REST is widely used because it is stateless, platform-independent, and uses standard web protocols.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Service A  ----&gt;  Service B (GET /data)</span></span>
<span class="line"><span>         &lt;----  Response (JSON data)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="asynchronous-communication-event-driven-model" tabindex="-1">Asynchronous Communication (Event-Driven Model) <a class="header-anchor" href="#asynchronous-communication-event-driven-model" aria-label="Permalink to &quot;Asynchronous Communication (Event-Driven Model)&quot;">​</a></h2><p>In asynchronous communication, the sender doesn’t wait for the recipient to respond. Instead, messages are sent and handled independently, which is useful when services need to be decoupled. This is typically done using messaging systems or event-driven architectures.</p><h3 id="message-brokers-message-queues" tabindex="-1">Message Brokers (Message Queues): <a class="header-anchor" href="#message-brokers-message-queues" aria-label="Permalink to &quot;Message Brokers (Message Queues):&quot;">​</a></h3><p>Microservices use message brokers like RabbitMQ, Kafka, or ActiveMQ to send messages to each other asynchronously. The sender pushes the message into the broker, and the receiver pulls the message when ready.</p><p>Example: Service A sends a message to a queue or topic, and Service B listens to that queue.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Service A  ----&gt;  Message Queue/Topic  ----&gt;  Service B</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,13),r=[t];function i(c,d,l,h,u,p){return a(),s("div",null,r)}const g=e(o,[["render",i]]);export{v as __pageData,g as default};
